1.2 스칼라의 확장성이 가능한 이유

=>> 객체지향 + 함수형 이니까

- 스칼라는 객체지향적이다
	- Simula, Smalltalk 로부터 시작한 개념.
	- 단점 : 어떤 객체의 멤버도 아닌 static을 허용, 원시타입(자바의 int) 등으로 인해 확장성을 제한하는 성가신 경향 있음.
	
	- 반면 스칼라는 100% pure 객체지향 언어다. 모든 값이 객체이며 모든 연산자는 메소드 호출이다. int 없고 Int 있다.
	- 이 기능덕에 얼랑의 ! 메소드도 구현이 가능한 것이다.
	- 객체조합이 타언어보다 뛰어난 이유는 스칼라의 트레이트
		- 자바 인터페이스와 비슷, 메소드 정의, 필드 정의, mixin 조합
		- 이것을 통해, 한 클래스의 여러 가지 측면을 별도의 트레이트에 캡슐화 할 수 있다.
		- 믹스인은 다중상속과 비슷해보이나, 상속 없이 새로운 기능을 아무 서브클래스에서 섞어 넣을 수 있다.
		- 트레이트는 끼워 넣기 좋은 pluggable 구성요소. 따라서 다이아몬드 상속도 피한다.

- 스칼라는 함수형이다
	- 함수형의 기초는 1930년대 Alonzo Church 의 lambda calculus
	- 최초 함수형 언어는 1950년대 Lisp, 그 외에 스킴, SML, 얼랑, 하스켈, 오캐멀, F#
	- 함수형은 학계에서는 유명하나 산업계에서는 널리 쓰이지 못함
	
	- 함수가 first class 일급 계층이다. 함수가 정수나 문자열과 동일한 자격을 가진다. 변수, 인자로도 취급 된다.
		- 함수를 일반화함으로써 표현력이 엄청나게 늘어난다.
	- 입력 값을 출력 값으로 변환해야 하며, 데이터를 그 자리에서 변경하지 말아야 한다.
		- 예를 들어, 자바의 String 은 replace를 하면 새 객체가 생기나(변경불가능객체), 루비는 그렇지 않다.
		따라서 문자열만 보자면 자바는 함수형 언어이나 루비는 아니다.
		- 데이터 변경이 없다는 것은 부수효과가 없다는 것을 의미한다. (=참조 투명)
	- 되도록이면 명령형 프로그램은 피하자....
		