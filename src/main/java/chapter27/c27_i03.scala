package chapter27

/**
 * 27.3 표준 애노테이션
 * 
 * 1. 사용금지(deprecation)
 * 
 * 인자로 문자열을 넘기면, 경고 메시지와 해당 문자열을 함께 표시한다.
 * 대신 사용할 내용을 알려줄 수 있다.
 * 
 * @deprecated ("use newShinyMethod() instead")
 * 
 * 2. volatile 필드
 * 
 * 동시 프로그래밍은 변경 가능한 상태를 공유하는 경우를 잘 처리하지 못한다. 따라서 스칼라에서는 최소한의
 * 변경 가능 상태만 공유하고, 메시지 전달을 중심으로 동시성을 지원하는데 초점을 맞추고 있다.
 * 
 * 그러나 프로그래머가 변경 가능 상태를 사용하고 싶을 때가 있는데 @volatile 애노테이션은 그럴 때
 * 도움이 된다. 이 애노테이션은 컴파일러에게 대상 변수를 여러 스레드가 사용한다는 점을 알린다.
 * 컴파일러는 여러 스레드에서 접근해도 스레드의 동작을 더 예측하기 좋게 그 변수를 구현한다. 대신,
 * 변수 읽기나 쓰기 속도는 더 느려진다. @volatile 키워드가 보장하는 내용은 플랫폼 마다 다르다.
 * 
 * 자바 플랫폼에서는 자바 코드에서 필드를 만들고 자바의 volatile 수식자로 그 필드를 수식한 것과
 * 같은 결과를 얻는다.
 * 
 * 3. 이진 직렬화
 * 
 * 많은 언어가 이진 직렬화 프레임워크를 제공한다. 객체를 바이트 스트림으로 바꾸거나 그 반대로 바꾸는 일을
 * 해결해 준다. 스칼라는 스칼라만의 직렬화 프레임워크가 존재하지 않기에, 플랫폼의 프레임워크를
 * 사용해야 한다. 대신 스칼라에서는 여러 프레임워크에서 유용하게 쓸 수 잇는 세 가지 애노테이션을
 * 제공한다. 또한 자바의 방식대로 해석한다.
 * 
 * 첫 번째 애노테이션은 클래스가 직렬화 가능한지를 표시. 예를 들어, 소켓 핸들이나 GUI 윈도는
 * 직렬화할 수 없다. 따라서 직렬화 가능한 클래스라면 @serializagble 을 추가해야 한다.
 * 
 * 두 번째는 직렬화 가능한 클래스에서 시간에 따른 변경사항을 다루도록 돕는다. 현재 버전에
 * @SerialVersionUID(1234)와 같이 일련번호를 붙인다. 프레임워크는 이 번호를 생성한
 * 바이트 스트림에 넣는다. 나중에 바이트 스트림을 읽어와서 객체로 바꾸려고 시도할 때, 프레임워크가
 * 클래스의 현재 버전과 스트림의 일련번호가 같은지 비교할 수 있다. 호환이 불가능한 변경을 가했다면
 * 프레임워크가 옛 버전의 클래스 인스턴스를 자동으로 거부할 것이다.
 * 
 * 마지막으로 직렬화해서는 안 되는 필드를 표시하는 @transient 애노테이션을 제공한다.
 * 어떤 필드를 @transient로 표시하면 그 필드가 들어 잇는 객체를 프레임워크가 직렬화하더라도,
 * 그 필드는 직렬화하지 않는다. 객체를 재로딩(역직렬화)할 때는 @transient로 표시한
 * 필드의 타입의 디폴트 값으로 다시 설정한다.
 * 
 * 4. 자동 get, set 메소드
 * 
 * 보통 스칼라 코드에는 명시적인 필드 get, set 메소드가 필요 없다.
 * 하지만 플랫폼에 따라 몇몇 프레임워크는 get, set 메소드를 꼭필요로 하는 경우가 있다.
 * 이를 위해 스칼라는 @scala.reflect.BeanProperty 애노테이션을 제공한다.
 * 필드에 이 애노테이션을 추가하면 컴파일러가 자동으로 get, set 메소드를 만들어 준다.
 * crazy 필드에 대해 setCrazy, getCrazy가 생ㅅ어된다.
 * 
 * 이렇게 만들어진 메소드는 컴파일 완료 후에만 사용 가능하다.
 * 
 * 5. tailrec
 * 
 * 꼬리 재귀 함수일 필요가 있는 메소드에 애노테이션한다. 재귀의 깊이가 아주 깊을 것 같은 함수에 사용..
 * 최적화함을 확실히 하기 위해 애노테이션을 하며, 할 수 없다면 컴파일러는 오류 메시지와 이유를 표시한다.
 * 
 * 6. unchecked
 * 
 * 컴파일런ㄴ 패턴 매치 시 @unchecked 애노테이션을 이해할 수 있다. 이것은 컴파일러에게
 * 매치가 모든 경우를 다 다루는지 걱정하지 않게 한다. (15.5절 참고)
 * 
 * 7. 네이티브 메소드
 * 
 * @native 애노테이션은 컴파일러에게 메소드 구현이 스칼라 코드가 아니고 런타임을 통해 주어진다는 사실을
 * 알려준다. 이를 보고 출력시 적절한 플래그를 설정해 준다. JNI 등으로 실제 구현을 제공해주는 것은
 * 개발자의 책임이다.
 * 
 * @native 애노테이션을 사용할 때 메소드 본문을 꼭 넣어줘야 한다. 그렇지만 그 본문은 출력에는
 * 들어가지 않는다.
 * 
 * 
 * 27.4 결론
 * 
 * 31장에서는 자바의 애노테이션 정보를 제공한다. 자바를 대상으로 할 때만 사용 가능한 애노테이션을 다루며,
 * 자바를 목적으로 할 때 표준 애노테이션이 추가로 의미하는 바를 살펴본다. 또한 자바 기반의 매커니즘을 사용해
 * 스칼라에서 쓸 애노테이션을 만드는 방법도 다룬다.
 */
object c27_i03 {
  
}