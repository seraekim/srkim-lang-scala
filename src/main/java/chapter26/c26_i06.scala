package chapter26

/**
 * 26.6 익스트랙터와 케이스 클래스
 * 
 * 아주 유용하긴 하지만, 케이스 클래스에는 데이터의 구체적인 표현이 드러난다는 단점이 있다.
 * 이는 그 생성자 패턴에 있는 클래스 이름이 셀렉터 객체의 구체적인 표현 타입과 대응한다는 뜻이다.
 * 
 * case C(...)
 * 
 * 여러분은 이 셀렉터 식이 클래스 C의 인스턴스라는 사실을 안다. 익스트랙터는 데이터 표현과 패턴 사이에 존재하는
 * 이런 연결을 끊는다. 이런 특성을 표현 독립성(representation independence)이라 한다.
 * 커다란 열린 시스템에서는 표현 독립성이 매우 중요하다. 클라이언트에는 영향을 끼치지 않으면서, 컴포넌트가
 * 사용하는 구현 타입을 변경할 수 있기 때문이다.
 * 
 * 케이스 클래스의 계층구조를 변경하면 클라이언트 코드에 영향을 주지만, 익스트랙터는 이런 문제가 없다.
 * 익스트랙터가 데이터 표현과 클라이언트에게 보여주는 방식 사이에 간접 계층을 제공하기 때문이다.
 * 
 * 반면 케이스 클래스가 익스트랙터보다 더 좋은 점도 몇 가지 있다.
 * 
 *  - 1. 설정하고 정의하기가 훨씬 쉽고, 코드가 적게 필요하다.
 *  - 2. 더 효과적인 패턴 매치 가능. 스칼라 컴파일러 입장에서 더 잘 최적화 하기 때문. 케이스 클래스의
 *  매커니즘은 고정이지만, 익스트랙터의 unapply나 unapplySeq 메소드 안에서는 거의 아무일이나 하기 때문.
 *  - 3. 봉인된 케이스 클래스를 상속하는 경우, 패턴 매치가 모든 가능한 패턴을 다 다루는지 컴파일러가 검사하여 경고.
 *  익스트랙터에는 이러한 검사가 없다.
 * 
 * 닫힌 앱플리케이션 코드라면 케이스 클래스, 어떤 타입을 미리 알지 못하는 여러 클라이언트에게 노출할 필요가 있다면
 * 익스트랙터를 사용하는 편이 더 좋다. 이를 항상 결정할 필요는 없다. 항상 케이스 클래스로 시작한다음, 필요에 따라
 * 익스트랙터로 바꿀 수 있다.
 * 
 * 26장 전자우편주소 예제와 같이, 시작부터 타입과 패턴의 구조가 서로 맞아 떨어지지 않는다는 사실이 분명하면 익스트랙터가
 * 유일한 방법이다.
 */
object c26_i06 {
  
}