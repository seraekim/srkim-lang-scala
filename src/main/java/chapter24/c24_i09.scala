package chapter24

/**
 * 24.9 변경 불가능한 구체적인 컬렉션 클래스
 * 
 * 스칼라가 제공하는 변경 불가능한 구체적인 컬렉션 클래스는 다양하며, 각각은 구현하는 트레이트(맵, 집합, 시퀀스)나
 * 무한한지 여부, 여러 연산의 속도 등이 다르다.
 * 
 * 1. 리스트
 * 
 * 리스트는 유한한 변경 불가능한 시퀀스다. head, tail에 접근하는데 상수 시간이 걸린다. 다른 많은 연산은
 * 선형 시간이 걸린다.
 * 
 */
object c24_i09 extends App {
  /*
   *  2. 스트림
   * 
   * 스트림은 리스트와 비슷하지만, 원소를 지연 계산한다는 점이 다르다. 이로 인해 스트림은 무한할 수가 있다. 외부에서
   * 요청하는 원소만 계산한다. 그 외에는 리스트와 비슷하다.
   * 리스트를 :: 연산자로 구성하는 반면, 스트림은 비슷하게 생긴 #::를 사용해 구성한다.
   * 
   * 인터프리터는 Stream(1,?) 식으로 tail 부분은 표시하지 않는데, 이는 아직 계산이 이뤄지지 않았기 때문이다.
   */
  val str = 1 #:: 2 #:: 3 #:: Stream.empty
  /*
   * 다음 함수는 거짓말 처럼 간단하다. 피보나치 수열인데, 무한 재귀 호출 없이 계산한다는 점이다.
   * #:: 대신, ::를 사용했다면, 이 함수에 대한 호출이 다른 호출을 다시 만들어내서 무한 재귀가 일어났을 것이다.
   */
  def fibFrom(a: Int, b: Int): Stream[Int] = a #:: fibFrom(b, a + b)
  
  // 2개의 1, 1로 시작하는 피보나치 수열 앞부분의 일부를 보여준다.
  val fibs = fibFrom(1, 1).take(7)
  println(fibs.toList)
  
  /*
   * 3. 벡터
   * 
   * 리스트는 head 는 상수시간, 그 외의 원소에 접근하려면 선형에 비례하는 시간이 걸린다. 벡터는 헤드가 어닌 원소도
   * 효율적으로 접근할 수 있다. 리스트의 헤드에 접근하거나 배열의 원소를 읽는 경우보다는 더 큰 상수이긴 하지만,
   * 그래도 상수는 상수다. 그 결과 벡터를 사용하는 알고리즘은 시퀀스의 헤드에만 접근하고자 조심할 필요가 없다.
   */
  val vec = scala.collection.immutable.Vector.empty
  val vec2 = vec :+ 1 :+ 2
  val vec3 = 100 +: vec2
  vec3(0)
  /*
   * 벡터는 넓고 얕은 트리로 표현한다. 일반적인 경우 원소 선택은 최대 5단계 정도의 기본 배열 접근으로 가능하다.
   * 벡터는 변경 불가능하기 때문에 벡터의 원소를 그 자리에서 바꿀 수 없다. 하지만 updated 메소드를 사용해
   * 주어진 벡터와 원소가 단 하나만 다른 새 백터를 만들 수 있다.
   */
  val vec4 = Vector(1, 2, 3)
  vec4 updated (2, 4) // index 2를 4의 값으로
  vec4 // 그대로 임
  /*
   * 벡터가 빠른 임의 접근 읽기와 빠른 임의 접근 변경 사이에서 균형을 잘 잡고 있기 때문에, 변경 불가능한 인덱스가 있는
   * 시퀀스의 기본 구현은 벡터다.
   */
  collection.immutable.IndexedSeq(1, 2, 3) // = Vector(1,2,3)
  
  /*
   * 4. 변경 불가능한 스택
   * 
   * 후입선출 시퀀스가 필요하다면 Stack을 사용할 수 있다.
   * push(넣기), pop(빼기), top(확인)
   */
  val stack = scala.collection.immutable.Stack.empty
  val hasOne = stack.push(1)
  println(stack) // 그대로 임
  hasOne.top
  hasOne.pop
  /*
   * 기능상 리스트가 스택을 모두 포함하기 때문에, 스칼라에서 사용하는 경우는 드물다.
   * 스택의 push는 리스트의 ::와 같고, pop은 tail과 같다.
   * 
   * 5. 변경 불가능한 큐
   * 
   * 스택과 비슷하지만 선입선출을 제공한다.
   */
  val empty = scala.collection.immutable.Queue[Int]()
  val has1 = empty.enqueue(1) // 원소하나 추가
  val has123 = has1.enqueue(List(2, 3)) // 컬렉션은 여러원소 추가
  val (element, has23) = has123.dequeue // 제거한 원소와 큐의 나머지 부분을 반환
  
  /*
   * 6. 범위
   * 
   * 간격이 일정한 정수를 순서대로 나열한 시퀀스다.
   */
  1 to 3 // Range(1,2,3)
  5 to 14 by 3 // Range(5, 8, 11, 14)
  1 until 3 // Range(1, 2)
  
  /*
   * 7. 해시 트라이
   * trie 는 retrieval (검색/인출)에서 온 것이며 발음은 tree 또는 try이다.
   * 해시 트라이는 변경 불가능한 집합이나 맵을 효율적으로 구현하는 표준적인 방법이다. 벡터와 비슷하게 32개의 원소나
   * 32개의 하위 트리를 포함하는 노드를 사용하는 트리다. 하지만 선택 시 해시 코드를 활용한다. 충분히 빠른 검색,
   * 효율적인 함수형 추가(+)와 제거(-) 사이의 균형을 잘 잡고 있다. 그래서 스칼라의 맵이나 집합에서는 기본 구현으로
   * 트라이를 사용한다. 원소가 5개 미만인 집합이나 맵은 스칼라가 추가로 최적화한다.
   * 
   * 8. 적흑 트리
   * 
   * 일부 노드는 빨간색, 일부 노드는 검은색으로 표시해둔 균형 2진 트리다. 트리 크기(노드 숫자)의 로그에 비례한
   * 시간안에 끝난다. 스칼라는 집합과 맵에 대한 내부 표현으로 적흑 트리를 제공한다. 이를 사용하려면
   * TreeSet 이나 TreeMap을 사용해야 한다.
   * 
   * 또한 적흑 트리는 스칼라 SortedSet의 표준 구현이기도 하다. 적흑 트리를 사용하면 모든 원소를 정렬 순서대로
   * 방문할 수 있는 효율적인 이터레이터를 만들 수 있기 때문이다.
   */
  val set = collection.immutable.TreeSet.empty[Int]
  set + 1 + 3 + 3
  
  /*
   * 9. 변경 불가능한 비트 집합
   * 
   * 내부적으로 비트 집합은 64비트 Long의 배열을 사용한다. 원소 포함 여부 검사는 상수 시간이 걸리고, 원소를
   * 추가하는데는 비트집합의 배열에 있는 Long의 개수에 선형으로 비례한 시간이 걸린다. 원소가 x라면 x/64개의 Long
   * 이 들어간 배열이 필요하기 때문이다.
   */
  val bits = scala.collection.immutable.BitSet.empty
  val moreBits = bits + 3 + 4 + 4 // BitSet(3, 4)
  moreBits(3) // true
  moreBits(0) // false
  
  /*
   * 10. 리스트 맵
   * 
   * 리스트 맵은 키값 쌍의 연결 리스트로 맵을 표현한다. 전체 리스트를 이터레이션 해야하니, 리스트 맵 연산은
   * 맵의 크기에 선형으로 비례하여 시간이 걸린다. 실제로 대부분의 경우 표준적인 변경 불가능 맵이 더 빠르기에
   * 스칼라에서 리스트 맵을 사용할 일은 거의 없다. 맵의 첫 원소를 다른 원소들보다 더 자주 선택해야 하는 방식으로
   * 맵을 구성하는 경우에 쓴다.
   */
  val map = collection.immutable.ListMap(1-> "one", 2 -> "tow")
  map(2)
}