package chapter24

/**
 * 24.6 집합
 * 
 * 집합은 원소 중복을 허용하지 않는 Iterable이다.
 * 
 *  - 검사: apply, subsetOf, contains. set(elem)은 set contains elem과 같다. (=set.apply)
 *  원소가 들어있는지 검사할 수 있으며, Boolean을 반환한다.
 *  - 추가 연산: +, ++
 *  - 제거 연산: -, --
 *  - 집합 연산: 교집합, 합집합, 차집합이 있는데 각각 intersect(&), union(|), diff(&~)이다.
 *  
 *  Set 트레이트가 Traversable에서 상속한 ++는 union 이나 |에 대한 별명으로 볼 수 있지만,
 *  union이나 |은 집합만을 취하는 바면 ++는 Traversable 인자를 취할 수 있다.
 *  
 *  변경 가능 집합에는 원소를 추가, 제거, 변경하는 메소드가 더 들어간다.
 *  
 *  변경 가능 집합도 원소 추가를 위한 +, ++나 원소 제거를 위한 -, --를 제공하지만, 이런 연산은 집합을 복사하기 때문에
 *  변경 가능 집합에서는 잘 사용하지 않는다. 변경 가능 집합에서는 더 효율적인 대안으로 변경 메소드 +=와 -=를 제공한다.
 *  
 *  += 와 -=의 다른 버전으로 add와 remove도 제공하는데 차이점은 연산이 집합에 효과가 있었는지 알려주는 불리언 값을
 *  반환한다는 점뿐이다.
 *  
 *  빈 집합은 싱글톤 객체를 단 하나 사용한다. 원소가 4개 이하인 집합은 모든 원소를 필드로 저장하는 방식을 택한다. 원소가 4개를 넘어가는
 *  변경 불가능한 집합은 해시 트라이(hash trie)를 사용한다.
 *  
 *  따라서 변경 가능 집합보다 원소 4개 이하인 변경 불가능한 집합은 훨씬 작고 효율적이다. 따라서 집합 크기가 작으리라 예상한다면, 변경 불가능한
 *  집합을 사용하고자 노력하라.
 *  
 *  Set의 하위 트레이트로는 SortedSet과 BitSet이 있다.
 *  
 *  1. 정렬 집합
 *  
 *  원소를 집합에 추가한 순서와 관계없이, 정렬 순서대로 원소를 순회할 수 있는 집합이다. 기본 표현은 왼쪽 하위 트리에 있는 원소들이
 *  오른쪽 하위 트리에 있는 원소들보다 더 작아야 한다는 불변조건(invariant)을 지키는 순서가 정해진 이진 트리다.
 *  이 방식을 통해서 간단한 중위 순회(in-order traversal)만으로 모든 트리 원소를 점점 커지는 순서로 돌려줄 수 있다.
 *  
 *  스칼라의 immutable.TreeSet 클래스는 적흑 트리(red-black tree)를 사용해 이런 순서에 대한 불변조건을 유지하는
 *  동시에 트리의 균형을 유지한다. 즉 트리의 뿌리로부터 잎에 이르는 거리가 거의 같다는 뜻이다.
 */
object c24_i06 extends App {
  val fruit = Set("apple", "peach")
  println(fruit("peach"))
  
  // 빈 트리 집합을 만들려면, 원하는 순서를 지정해야만 한다. String을 역순으로 배열하는 Ordering 클래스
  val myOrdering = Ordering.fromLessThan[String](_ > _)
  
  // 이를 사용해 빈 트리 집합 만들기
  import scala.collection.immutable.TreeSet
  TreeSet.empty(myOrdering)
  
  // 순서를 지정하는 대신 빈 집합의 원소 타입을 지정할 수도 있다. 그러면 해당 원소 타입의 기본 순서를 사용한다.
  val set = TreeSet.empty[String]
  
  // 새 집합을 트리 집합으로부터 만드는 경우(집합들을 합하거나, 필터링..) 원래 집합의 순서를 그대로 유지할 것이다.
  val numbers = set + ("one", "two", "three", "four")
  
  /*
   * 정렬 집합은 원소의 범위도 지원한다. 예를 들어 range 메소드는 첫 원소부터 시작해, 끝 원소 바로 직전의 원소를 반환한다.
   * from 의 경우 집합의 순서에 따라 주어진 인자보다 크거나 같은 모든 원소를 반환한다.
   */
  println(numbers range ("one", "two"))
  println(numbers from "three")
  
  /*
   * 2. 비트 집합
   * 
   * 비트 집합은 음이 아닌 정수 원소들을 저장하는 집합으로, 하나 이상의 워드에 비트를 꾸려 넣는 방식으로 구현한다. 비트 집합의
   * 내부 표현은 Long의 배열을 사용한다. 첫 번째 Long은 0부터 63까지의 정수를 처리하고, 두 번째 Long은 64부터 127
   * 까지를 처리하는 식의 알고리즘을 쓴다. (원소들이 0~ 127 정수 범위에 속하는 변경 불가능한 집합은 배열을 없애고
   * 비트를 한두 개의 Long 필드에 직접 저장하는 방식으로 최적화 한다.)
   * 
   * 만약 N이 가장 큰 정소라면, 집합에는 N/64개의 Long워드, 또는 N/8개의 바이트와 상태 정보를 저장하기 위한 약간의
   * 부가 비용이 더 들어간다.
   * 
   * 따라서 작은 원소가 많이 들어 있는 경우 비트 집합은 다른 집합보다 훨씬 작은 공간을 차지한다. contains를 사용한 원소
   * 포함 검사나 +=, -=를 사용한 원소 추가나 제거가 아주 효율적이라는 또 다른 이점도 얻을 수 있다.
   */
}