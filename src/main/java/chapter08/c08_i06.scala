package chapter08

/**
 * 8.6 부분 적용한 함수
 *
 * 앞의 예제에선 각 파라미터를 밑줄로 대체했는데, 전체 파라미터 목록을 밑줄로도 바꿀 수 있다.
 *
 * 함수에 필요한 인자를 전부 적용하지 않은 표현식을 말한다.
 */
object c08_i06 extends App {
  val someNumbers = List(-11, -10, 0, 5, 10)
  someNumbers.foreach(println _)

  /*
   * 아래와 같이 _ 조차도 생략이 가능한 경우는
   * 함수가 필요한 위치라는 것이 명확한 경우이다.
   * foreach는 명확히 함수를 인자로 받는다. 컴파일러는 이 사실을 안다.
   */
  someNumbers.foreach(println)
  
  def sum(a: Int, b: Int, c: Int) = a + b + c
  sum(1, 2, 3)

  /*
   * 함수형 언어에서는 호출(call, invoke) 보단 적용(apply)이란 표현을 쓴다.
   * 
   * 프로그램 계산 모델을 명령을 실행하는 것이 아니라, 값을 바꿔치기 하면서
   * 더 이상 축약 규칙을 줄일 수 없을 때까지 줄여나가는 과정으로 이해한다.
   * 
   * 함수(인자들) 식을 계산할 때, 모든 파라미터 변수들을 실제 전달받은 인자값으로 바꿔치기 하는데
   * 이를 베타 축약(beta reduction)이라 하며, 여기서 다시 축약해 값을 얻는다.
   * 따라서, 서브루틴으로 실행 제어를 넘긴다는 의미로 호출이 아닌 적용이란 단어를 쓴다.
   * 
   * a는 함수 값 객체다.
   * 컴파일러가 자동으로 만들어낸 클래스에는 인자 3개를 받는 apply 메소드가 있다.
   * 자동으로 만들어진 클래스는 Function3이라는 트레이트를 상속한다.
   */
  val a = sum _
  a(1, 2, 3)
  a.apply(1, 2, 3)

  // 두번째 인자는 제공하지 않음. 즉 컴파일러는 인자를 하나만 받는 apply 제공
  val b = sum(1, _: Int, 3)
  
  b(2) // b(2) 는 sum(1,2,3)을 호출
  
  /*
   * 스칼라는 특이하게 전통형 함수형언어(하스켈, ML)과 달리
   * 함수의 인자를 다 넘겨주지 않으면 에러가 난다. 즉 자바와 같은 명령형 관점도 취하는 것이다.
   * 혼란 스러운 상황을 막기위해 간단하게나마 _ 인자를 표시하도록 요구한다.
   */
  //val c = sum(1)
}