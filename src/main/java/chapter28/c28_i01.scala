package chapter28

/**
 * 28장 XML 다루기
 * 
 * XML 리터럴로 노드를 만드는 방법, 파일에 쓰고 읽는 방법, 노드를 질의 메소드나
 * 패턴 매치를 사용해 분석하는 방법 등을 보여준다.
 * 
 * 28.1 반 구조화 데이터
 * 
 * XML은 semi-structured data의 한 형태다. 데이터를 트리 구조로 조직화해뒀기 때문에,
 * 일반적인 문자열보다는 더 구조화 되어 있다. 태그 사이에 임의의 텍스트가 들어갈 수 있고,
 * 타입 시스템도 없기 때문에, 프로그래밍 언어의 객체보다는 덜 구조화되어 있다.
 * 
 * 반 구조화 데이터는 파일에 프로그램 데이터를 저장하거나, 네트워크를 통해 데이터를 보내기 위해
 * 직렬화할 경우 아주 유용하다. 구조화 데이터를 바이트 수준으로 변환하는 대신,
 * 반 구조화 데이터를 만들거나, 반 구조화에서 구조화 데이터를 만들 수 있다.
 * 
 * 그 후 반 구조화 데이터와 이진 데이터를 변환해주는 기존 라이브러리 루틴을 사용하면,
 * 데이터 변환에 필요한 시간을 아껴서 더 중요한 문제에 집중할 수 있다.
 * 
 * 스칼라는 XML 처리를 특별히 지원하기로 했다.
 * 
 * XML을 생성하고, 정규식으로 처리하고, 패턴매치를 사용하는 것을 보여준다.
 * 
 * 28.2 XML 개요
 * 
 * 태그가 매치돼야 하므로, XML은 내포 관계에 있는 원소들로 구조화된다.
 * 
 * 각 시작과 끝 태그는 엘리먼트를 이루며, 각 엘리먼트는 다른 엘리먼트에 포함될 수 있다.
 * <pease></pease> 는 줄여서 <pease/> 라고 할 수 있다.
 * 
 * 시작 태그에는 attribute가 있을 수 있다. 이름 값 쌍이다. 이름과 값 사이에는
 * 등호를 적는다.
 * <pod peas="3" strings="true"/>
 * 
 * 28.3 XML 리터럴
 * 
 * Node 클래스 : 모든 XML 노드의 추상 슈퍼클래스다.
 * Text : 텍스트만 포함하는 노드. <a>asdf</a> 에서 asdf 부분이 Text 클래스.
 * NodeSeq : 노드의 시퀀스. 각각의 개별 노드를 한 원소짜리 NodeSeq라 생각할 수 있음.
 */
object c28_i01 extends App {
  val res0 =
  <a>
    This is some XML.
    Here is a tag: <atag/>
  </a>                                            //> res0  : scala.xml.Elem = <a>
                                                  //|     This is some XML.
                                                  //|     Here is a tag: <atag/>
                                                  //|   </a>
  // XML 리터럴의 중간에 중괄호로 이스케이프한 스칼라 코드를 넣을 수 있음.
  <a> {"Hello"+", word"} </a>
  
  // xml.NodeSeq.Empty 은 아무것도 없음을 XML 노드로 표현한다.
  val yearMade = 1955
  <a> { if (yearMade < 2000) <old>{yearMade}</old>
        else xml.NodeSeq.Empty }
  </a>
  
  <a> {3 + 4} </a>
  
  // <, >, & 문자는 이스케이프 한다.
  "<a>" + "</a>potential security hole<a>" + "</a>"
  
}